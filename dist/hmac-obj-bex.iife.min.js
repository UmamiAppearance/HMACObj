var HMACObj=function(){"use strict";class e extends Error{constructor(e){super(e),this.name="PermissionError"}}const t=async(e,t,s="raw",i=!1)=>await globalThis.crypto.subtle.importKey(s,e,{name:"HMAC",hash:{name:t}},i,["sign","verify"]),s=async(e,t=!1)=>await globalThis.crypto.subtle.generateKey({name:"HMAC",hash:{name:e}},t,["sign","verify"]),i=async(t,s="raw")=>{if(!t.extractable)throw new e("Key exports are not allowed. You can permit this during key-generation.");return await globalThis.crypto.subtle.exportKey(s,t)},r=async(e,t)=>await globalThis.crypto.subtle.sign({name:"HMAC",hash:t.algorithm.hash.name},t,e),n=async(e,t,s)=>await globalThis.crypto.subtle.verify("HMAC",s,t,e),o=(e,t)=>{if(!e)throw new TypeError("Missing required parameter 'digestmod'.");let s=0|[].concat(String(e).match(/[0-9]+/)).at(0);if(e=`SHA-${s}`,!t.includes(e))throw new TypeError(`Available digestmod are: '${t.join(", ")}'.`);return 1===s&&(s=160),[e,s]};class a{static toBytes(e){return!ArrayBuffer.isView(e)||"undefined"!=typeof Buffer&&e instanceof Buffer||(e=e.buffer),[new Uint8Array(e),!1,"bytes"]}}class h{static get typeList(){return["buffer","bytes","uint8","view"]}static getType(e){if(!h.typeList.includes(e))throw new TypeError(`Unknown output type: '${e}'`);return e}static compile(e,t){let s;return s="buffer"===(t=h.getType(t))?e.buffer:"view"===t?new DataView(e.buffer):e,s}}class l{static makeDataView(e){const t=new ArrayBuffer(e);return new DataView(t)}static floatingPoints(e,t=!1){const s=this.makeDataView(8);return s.setFloat64(0,e,t),s}static numbers(e,t=!1){let s,i;if(Number.isInteger(e)){if(i="int",!Number.isSafeInteger(e)){let t,s,i;throw e<0?(t=Number.MIN_SAFE_INTEGER,s="smaller",i="MIN"):(t=Number.MAX_SAFE_INTEGER,s="bigger",i="MAX"),new RangeError(`The provided integer is ${s} than ${i}_SAFE_INTEGER: '${t}'\nData integrity is not guaranteed. Use a BigInt to avoid this issue.\n(If you see this error although a float was provided, the input has to many digits before the decimal point to store the decimal places in a float with 64 bits.)`)}e<0?e<-2147483648?(s=this.makeDataView(8),s.setBigInt64(0,BigInt(e),t)):e<-32768?(s=this.makeDataView(4),s.setInt32(0,e,t)):(s=this.makeDataView(2),s.setInt16(0,e,t)):e>0?e>4294967295?(s=this.makeDataView(8),s.setBigUint64(0,BigInt(e),t)):e>65535?(s=this.makeDataView(4),s.setUint32(0,e,t)):(s=this.makeDataView(2),s.setInt16(0,e,t)):s=new Uint16Array([0])}else i="float",s=this.floatingPoints(e,t);return[new Uint8Array(s.buffer),i]}static bigInts(e,t=!1){const s=new Array,i=t?"push":"unshift",r=18446744073709551616n;if(e<0)for(;e<-9223372036854775808n;)s[i](e%r),e>>=64n;else for(;e>=r;)s[i](e%r),e>>=64n;s[i](e);const n=8*s.length,o=this.makeDataView(n);return s.forEach(((e,s)=>{const i=8*s;o.setBigUint64(i,e,t)})),new Uint8Array(o.buffer)}static toBytes(e,t){let s,i=!1,r="bytes";if(e instanceof ArrayBuffer)s=new Uint8Array(e.slice());else if(ArrayBuffer.isView(e))s="undefined"!=typeof Buffer&&e instanceof Buffer?new Uint8Array(e):new Uint8Array(e.buffer.slice());else if("string"==typeof e||e instanceof String)s=(new TextEncoder).encode(e);else if("number"==typeof e){if(isNaN(e))throw new TypeError("Cannot proceed. Input is NaN.");if(e==1/0)throw new TypeError("Cannot proceed. Input is Infinity.");if(t.signed&&e<0&&(i=!0,e=-e),t.numberMode){const i=this.floatingPoints(e,t.littleEndian);s=new Uint8Array(i.buffer),r="float"}else[s,r]=this.numbers(e,t.littleEndian)}else if("bigint"==typeof e)t.signed&&e<0&&(i=!0,e*=-1n),s=this.bigInts(e,t.littleEndian),r="int";else{if(!Array.isArray(e))throw new TypeError("The provided input type can not be processed.");{const i=new Array;for(const s of e)i.push(...this.toBytes(s,t)[0]);s=Uint8Array.from(i)}}return[s,i,r]}}class c{static get typeList(){return["bigint64","bigint_n","biguint64","buffer","bytes","float32","float64","float_n","int8","int16","int32","int_n","str","uint8","uint16","uint32","uint_n","view"]}static getType(e){if(!this.typeList.includes(e))throw new TypeError(`Unknown output type: '${e}'`);return e}static makeTypedArrayBuffer(e,t,s,i){const r=e.byteLength,n=(t-e.byteLength%t)%t,o=i&&r>1?255:0;let a=e;if(n){a=new Uint8Array(r+n),a.fill(o);const t=s?0:n;a.set(e,t)}return a.buffer}static makeTypedArray(e,t,s,i){let r;if("int16"===t||"uint16"===t){const n=this.makeTypedArrayBuffer(e,2,s,i);r="int16"===t?new Int16Array(n):new Uint16Array(n)}else if("int32"===t||"uint32"===t||"float32"===t){const n=this.makeTypedArrayBuffer(e,4,s,i);r="int32"===t?new Int32Array(n):"uint32"===t?new Uint32Array(n):new Float32Array(n)}else if("bigint64"===t||"biguint64"===t||"float64"===t){const n=this.makeTypedArrayBuffer(e,8,s,i);r="bigint64"===t?new BigInt64Array(n):"biguint64"===t?new BigUint64Array(n):new Float64Array(n)}return r}static compile(e,t,s=!1,i=!1){let r;if(t=this.getType(t),i){let i;if(i=t.match(/^float/)?-this.compile(e,"float_n",s):-this.compile(e,"uint_n",s),"float_n"===t)return i;e=l.toBytes(i,{littleEndian:s,numberMode:!1,signed:!1})[0]}if("buffer"===t)r=e.buffer;else if("bytes"===t||"uint8"===t)r=e;else if("int8"===t)r=new Int8Array(e.buffer);else if("view"===t)r=new DataView(e.buffer);else if("str"===t)r=(new TextDecoder).decode(e);else if("uint_n"===t||"int_n"===t||"bigint_n"===t){if(1===e.length){const t=this.makeTypedArrayBuffer(e,2,s,i);e=new Uint8Array(t)}s&&e.reverse();let n=0n;e.forEach((e=>n=(n<<8n)+BigInt(e))),"uint_n"!==t&&(n=BigInt.asIntN(8*e.length,n)),r="bigint_n"!==t&&n>=Number.MIN_SAFE_INTEGER&&n<=Number.MAX_SAFE_INTEGER?Number(n):n}else if("float_n"===t)if(e.length<=4){let t;t=4===e.length?e:this.makeTypedArray(e,"float32",!1,i);r=new DataView(t.buffer).getFloat32(0,s)}else{if(!(e.length<=8))throw new RangeError("The provided input is to complex to be converted into a floating point.");{let t;t=8===e.length?e:this.makeTypedArray(e,"float64",!1,i);r=new DataView(t.buffer).getFloat64(0,s)}}else if("number"===t){if(8!==e.length)throw new TypeError("Type mismatch. Cannot convert into number.");const t=new Float64Array(e.buffer);r=Number(t)}else r=this.makeTypedArray(e,t,s,i);return r}}const u=l,d=c;class f extends TypeError{constructor(){super("The input is signed but the converter is not set to treat input as signed.\nYou can pass the string 'signed' to the decode function or when constructing the converter."),this.name="SignError"}}class p extends TypeError{constructor(e,t=null){null===t&&(t=`Character '${e}' is not part of the charset.`),super(t),this.name="DecodingError"}}class g{constructor(e){this.root=e,this.converterArgs={},this.#e()}setIOHandlers(e=u,t=d){this.inputHandler=e,this.outputHandler=t}#e(){this.root.addCharset=(e,t,s=[],i=!0)=>{const r=(e,s,i)=>{if(0===i&&s.length)return console.warn(`This converter has no ${e}. The following argument was ignored:\n'${s}'`),[];let r=i;if("string"==typeof s&&(s=[...s]),Array.isArray(s))r=s.length,s=new Set(s);else if(!(s instanceof Set))throw new TypeError(`The ${e} must be one of the types:\n'str', 'set', 'array'."`);if(s.size===i)return[...s];if(r!==i)throw new Error(`Your ${e} has a length of ${r}. The converter requires a length of ${i}.`);{const s={};(t=[...t]).forEach((e=>{e in s?s[e]++:s[e]=1}));let r="";i<100&&(r=`${t.join("")}\n`,t.forEach((e=>{s[e]>1?r+="^":r+=" "})));const n=Object.keys(s).filter((e=>s[e]>1));throw new Error(`You have repetitive char(s) [ ${n.join(" | ")} ] in your ${e}. Make sure each character is unique.\n${r}`)}};if(this.root.frozenCharsets)throw new Error("The charsets of this converter cannot be changed.");if("string"!=typeof e)throw new TypeError("The charset name must be a string.");i&&e in this.root.charsets&&console.warn(`An existing charset with name ${e} will get replaced.`);const n=r("charset",t,this.root.converter.radix),o=r("padding set",s,this.root.padCharAmount);this.root.charsets[e]=n,o.length&&(this.root.padChars[e]=o),i&&console.info(`New charset '${e}' was added and is ready to use`)},this.root.setDefaultCharset=e=>{if(!(e in this.root.charsets)){const t=Object.keys(this.root.charsets).join("\n   * ");throw new TypeError(`Charset ${e} was not found. Available charsets are:\n   * ${t}`)}this.root.version=e}}#t(e){return e.map((e=>`'${e}'`)).join(", ")}toSignedStr(e,t){return e=e.replace(/^0+(?!$)/,""),t&&(e="-".concat(e)),e}extractSign(e){let t=!1;return"-"===e[0]&&(t=!0,e=e.slice(1)),[e,t]}#s(e,t,s,i){throw new TypeError([`'${e}'\n\nParameters:`,i?"\n * valid declarations for IO handlers are 'bytesOnly', 'bytesIn', 'bytesOut'":"",this.root.isMutable.signed?"\n * pass 'signed' to disable, 'unsigned' to enable the use of the twos's complement for negative integers":"",this.root.isMutable.littleEndian?"\n * 'be' for big , 'le' for little endian byte order for case conversion":"",this.root.isMutable.padding?"\n * pass 'pad' to fill up, 'nopad' to not fill up the output with the particular padding":"",this.root.isMutable.upper?"\n * valid args for changing the encoded output case are 'upper' and 'lower'":"",`\n * valid args for the output type are ${this.#t(s)}`,t?`\n * the option(s) for version/charset are: ${this.#t(t)}`:"","\n * valid args for integrity check are: 'integrity' and 'nointegrity'",this.root.hasDecimalMode?"\n * 'decimal' for decimal-mode (directly converts Numbers including decimal values, without byte-conversion)":"","\n * 'number' for number-mode (converts every number into a Float64Array to keep the natural js number type)",Object.keys(this.converterArgs).length?`\n * converter specific args:\n   - ${(()=>Object.keys(this.converterArgs).map((e=>this.converterArgs[e].map((e=>`'${e}'`)).join(" and "))).join("\n   - "))()}`:"","\n\nTraceback:"].join(""))}validateArgs(e,t=!1){const s={decimalMode:this.root.decimalMode,integrity:this.root.integrity,littleEndian:this.root.littleEndian,numberMode:this.root.numberMode,options:this.root.options,outputType:this.root.outputType,padding:this.root.padding,signed:this.root.signed,upper:this.root.upper,version:this.root.version};for(const e in this.converterArgs)s[e]=this.root[e];if(!e.length)return t&&this.setIOHandlers(),s;const i=t=>!!e.includes(t)&&(e.splice(e.indexOf(t),1),!0),r=Object.keys(this.root.charsets),n={integrity:["nointegrity","integrity"],littleEndian:["be","le"],padding:["nopad","pad"],signed:["unsigned","signed"],upper:["lower","upper"],...this.converterArgs};if(t)if(i("bytes_only"))this.setIOHandlers(a,h);else{const e=i("bytes_in")?a:u,t=i("bytes_out")?h:d;this.setIOHandlers(e,t)}const o=this.outputHandler.typeList;if(i("number")&&(s.numberMode=!0,s.outputType="float_n"),i("decimal")){if(!this.root.hasDecimalMode)throw TypeError("Argument 'decimal' is only allowed for converters with a non-integer base.");s.decimalMode=!0,s.outputType="decimal",s.numberMode&&(s.numberMode=!1,console.warn("-> number-mode was disabled due to the decimal-mode"))}if(e.forEach((e=>{if("object"!=typeof e)if(e=String(e).toLowerCase(),r.includes(e))s.version=e;else if(o.includes(e))s.outputType=e;else{let i=!0;for(const t in n)if(n[t].includes(e)){if(i=!1,!this.root.isMutable[t])throw TypeError(`Argument '${e}' is not allowed for this type of converter.`);s[t]=Boolean(n[t].indexOf(e))}i&&this.#s(e,r,o,t)}else s.options={...s.options,...e}})),s.padding&&s.signed&&(s.padding=!1,console.warn("-> padding was set to false due to the signed conversion")),t)for(const e in s)this.root[e]=s[e];return s}signError(){throw new f}wrapOutput(e,t=0){if(!t)return e;const s=new RegExp(`.{1,${t}}`,"gu");return e.match(s).join("\n")}normalizeInput(e,t=!1){return t?String(e):String(e).replace(/\s/g,"")}}class y{constructor(e,t=null,s=null,i=0){this.radix=e,null!==t&&null!==s?(this.bsEnc=t,this.bsDec=s):[this.bsEnc,this.bsDec]=this.constructor.guessBS(e),this.decPadVal=i,this.powers={}}static guessBS(e){let t=e<8?e:Math.ceil(256/e);for(;t>8&&!(t%8);)t/=8;let s=0;for(;8*s*Math.log(2)/Math.log(e)<t;)s++;return[s,Math.ceil(8*s*Math.log(2)/Math.log(e))]}encode(e,t,s=!1,i=null){let r=this.bsEnc;0===r&&(r=e.byteLength);let n="";const o=r?(r-e.length%r)%r:0,a=new Array(o).fill(0);let h;if(s?(e.reverse(),h=[...a,...e]):h=[...e,...a],10===this.radix){let e=0n;for(let t=0;t<r;t++)e=(e<<8n)+BigInt(h[t]);return[e.toString(),0]}for(let e=0,s=h.length;e<s;e+=r){let s=0n;for(let t=e;t<e+r;t++)s=(s<<8n)+BigInt(h[t]);const a=new Array;let l,c=s;for(;c>=this.radix;)[c,l]=this.divmod(c,this.radix),a.unshift(parseInt(l,10));for(a.unshift(parseInt(c,10));a.length<this.bsDec;)a.unshift(0);let u="";a.forEach((e=>u=u.concat(t[e]))),i&&(u=i(u,o)),n=n.concat(u)}return[n,o]}decode(e,t,s=[],i=!0,r=!1){if(!e)return new Uint8Array(0);let n=this.bsDec;const o=[];let a;if([...e].forEach((e=>{const r=t.indexOf(e);if(r>-1)o.push(r);else if(i&&-1===s.indexOf(e))throw new p(e)})),0===n)n=o.length;else{a=(n-o.length%n)%n;const e=new Array(a).fill(this.decPadVal);r?o.unshift(...e):o.push(...e)}let h=new Array;for(let e=0,t=o.length;e<t;e+=n){let t=0n;for(let s=0;s<n;s++){const i=n-1-s,r=this.powers[i]||(()=>(this.powers[i]=BigInt(this.pow(i)),this.powers[i]))();t+=BigInt(o[e+s])*r}const s=[];let i,r=t;for(;r>=256;)[r,i]=this.divmod(r,256),s.unshift(parseInt(i,10));for(s.unshift(parseInt(r,10));s.length<this.bsEnc;)s.unshift(0);h.push(...s)}if(r){if(h.length>1){for(;!h[0];)h.shift();h.length||h.push(0),h.reverse()}}else if(this.bsDec){const e=this.padChars(a);h.splice(h.length-e)}return Uint8Array.from(h)}padBytes(e){return Math.floor(e*this.bsDec/this.bsEnc)}padChars(e){return Math.ceil(e*this.bsEnc/this.bsDec)}pow(e){return BigInt(this.radix)**BigInt(e)}divmod(e,t){return[e,t]=[BigInt(e),BigInt(t)],[e/t,e%t]}}class b{constructor(e=!0){this.charsets={},this.decimalMode=!1,this.frozenCharsets=!1,this.hasDecimalMode=!1,this.hasSignedMode=!1,this.integrity=!0,this.littleEndian=!1,this.numberMode=!1,this.outputType="buffer",this.padding=!1,this.padCharAmount=0,this.padChars={},this.nonASCII=!1,this.signed=!1,this.upper=null,e&&(this.utils=new g(this)),this.version="default",this.options={lineWrap:0},this.isMutable={integrity:!0,littleEndian:!1,padding:!1,signed:!1,upper:!1}}encode(e,t,s,...i){const r=this.utils.validateArgs(i);let[n,o,a]=this.utils.inputHandler.toBytes(e,r),h=null;t&&(h=t(r));let[l,c]=this.converter.encode(n,this.charsets[r.version],r.littleEndian,h);return r.signed&&(l=this.utils.toSignedStr(l,o)),r.upper&&(l=l.toUpperCase()),s&&(l=s({inputBytes:n,output:l,settings:r,zeroPadding:c,type:a})),this.utils.wrapOutput(l,r.options.lineWrap)}decode(e,t,s,i,...r){const n=this.utils.validateArgs(r);e=this.utils.normalizeInput(e,i);let o=!1;this.hasSignedMode&&([e,o]=this.utils.extractSign(e),o&&!n.signed&&this.utils.signError()),this.isMutable.upper&&(e=e.toLowerCase()),t&&(e=t({input:e,settings:n}));let a=this.converter.decode(e,this.charsets[n.version],this.padChars[n.version],n.integrity,n.littleEndian);return s&&(a=s({input:e,output:a,settings:n})),this.utils.outputHandler.compile(a,n.outputType,n.littleEndian,o)}}class w extends b{constructor(...e){super(),this.charsets.all=[..." !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"],this.charsets.sequence=[..."Hello World!"],this.charsets.default=["1"],this.charsets.tmark=["|","#"],this.converter=new y(10,0,0),this.hasSignedMode=!0,this.littleEndian=!0,this.signed=!0,this.isMutable.charsets=!1,this.isMutable.signed=!0,this.isMutable.upper=!0,this.utils.validateArgs(e,!0)}encode(e,...t){const s=this.utils.validateArgs(t);let i,r;[i,r]=this.utils.inputHandler.toBytes(e,s);let n=this.converter.encode(i,null,s.littleEndian)[0],o=BigInt(n);if(o>Number.MAX_SAFE_INTEGER)throw new RangeError("Invalid string length.");o>16777216&&console.warn("The string length is really long. The JavaScript engine may have memory issues generating the output string."),o=Number(o);const a=this.charsets[s.version],h=a.length;let l="";if(1===h)l=a.at(0).repeat(o);else if("all"===s.version)for(let e=0;e<o;e++){l+=a[Math.floor(Math.random()*h)]}else if("tmark"===s.version){const e=o%5;o>4&&(l=a.at(1).repeat((o-e)/5)),l+=a.at(0).repeat(e)}else for(let e=0;e<o;e++)l+=a[e%h];return l=this.utils.toSignedStr(l,r),s.upper&&(l=l.toUpperCase()),this.utils.wrapOutput(l,s.options.lineWrap)}decode(e,...t){const s=this.utils.validateArgs(t);let i;if(e=this.utils.normalizeInput(e),[e,i]=this.utils.extractSign(e),"all"!==s.version){const t=[...new Set(this.charsets[s.version])].join(""),i=new RegExp(`[^${t}]`,"g");e=e.replace(i,"")}e=String(e.length);const r=this.converter.decode(e,[..."0123456789"],[],"",s.integrity,s.littleEndian);return this.utils.outputHandler.compile(r,s.outputType,s.littleEndian,i)}}class m extends b{constructor(...e){super(),this.converter=new y(16,1,2),this.charsets.default=[..."0123456789abcdef"],this.padChars.default=[],this.hasSignedMode=!0,this.isMutable.signed=!0,this.isMutable.upper=!0,this.utils.validateArgs(e,!0)}encode(e,...t){return super.encode(e,null,null,...t)}decode(e,...t){return super.decode(e,(({input:e,settings:t})=>(e=e.replace(/^0x/,""),t.integrity||(e=e.toLowerCase().replace(/[^0-9a-f]/g,"")),e.length%2&&(e="0".concat(e)),e)),null,!1,...t)}}class v extends b{constructor(...e){super(),this.converter=new y(32,5,8),this.charsets.crockford=[..."0123456789abcdefghjkmnpqrstvwxyz"],this.padChars.crockford=["="],this.charsets.rfc3548=[..."abcdefghijklmnopqrstuvwxyz234567"],this.padChars.rfc3548=["="],this.charsets.rfc4648=[..."0123456789abcdefghijklmnopqrstuv"],this.padChars.rfc4648=["="],this.charsets.zbase32=[..."ybndrfg8ejkmcpqxot1uwisza345h769"],this.padChars.zbase32=["="],this.padCharAmount=1,this.hasSignedMode=!0,this.version="rfc4648",this.isMutable.littleEndian=!0,this.isMutable.padding=!0,this.isMutable.signed=!0,this.isMutable.upper=!0,this.utils.validateArgs(e,!0),this.padding=/rfc3548|rfc4648/.test(this.version),this.upper="crockford"===this.version}encode(e,...t){return super.encode(e,null,(({output:e,settings:t,zeroPadding:s})=>{if(!t.littleEndian&&s){const i=this.converter.padBytes(s),r=this.padChars[t.version].at(0);e=e.slice(0,-i),t.padding&&(e=e.concat(r.repeat(i)))}return e}),...t)}decode(e,...t){return super.decode(e,null,null,!1,...t)}}class E extends b{constructor(...e){super(),this.converter=new y(58,0,0),this.charsets.default=[..."123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],Object.defineProperty(this.padChars,"default",{get:()=>[this.charsets.default.at(0)]}),this.charsets.bitcoin=[..."123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],Object.defineProperty(this.padChars,"bitcoin",{get:()=>[this.charsets.bitcoin.at(0)]}),this.charsets.flickr=[..."123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],Object.defineProperty(this.padChars,"flickr",{get:()=>[this.charsets.flickr.at(0)]}),this.padding=!0,this.version="bitcoin",this.isMutable.padding=!0,this.isMutable.signed=!0,this.utils.validateArgs(e,!0)}encode(e,...t){return super.encode(e,null,(({inputBytes:e,output:t,settings:s,type:i})=>{if(s.padding&&"int"!==i){let i=0;const r=e.length,n=this.charsets[s.version].at(0);if(r){for(;!e[i];)if(i++,i===r){i=0;break}const s=i;s&&(t=n.repeat(s).concat(t))}}return t}),...t)}decode(e,...t){return super.decode(e,null,(({input:e,output:t,settings:s})=>{const i=this.charsets[s.version].at(0);if(s.padding&&e.length>1){let s=0;for(;e[s]===i;)s++;const r=s;r&&(t=Uint8Array.from([...new Array(r).fill(0),...t]))}return t}),!1,...t)}}class A extends b{constructor(...e){super(),this.converter=new y(64,3,4),this.charsets.default=[..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],this.padChars.default=["="],this.charsets.urlsafe=this.charsets.default.slice(0,-2).concat(["-","_"]),this.padChars.urlsafe=["="],this.padCharAmount=1,this.padding=!0,this.isMutable.padding=!0,this.utils.validateArgs(e,!0)}encode(e,...t){return super.encode(e,null,(({output:e,settings:t,zeroPadding:s})=>{if(s){const i=this.converter.padBytes(s),r=this.padChars[t.version].at(0);e=e.slice(0,-i),t.padding&&(e=e.concat(r.repeat(i)))}return e}),...t)}decode(e,...t){return super.decode(e,null,null,!1,...t)}}class x extends b{constructor(...e){super(),this.converter=new y(64,3,4),this.charsets.default=[..."`!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"],Object.defineProperty(this.padChars,"default",{get:()=>[this.charsets.default.at(0)]}),this.charsets.original=[" ",...this.charsets.default.slice(1)],Object.defineProperty(this.padChars,"original",{get:()=>[this.charsets.original.at(0)]}),this.charsets.xx=[..."+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"],Object.defineProperty(this.padChars,"xx",{get:()=>[this.charsets.xx.at(0)]}),this.padding=!0,this.buffering=!1,this.utils.converterArgs.buffering=["nobuffering","buffering"],this.isMutable.buffering=!0,this.header=!1,this.utils.converterArgs.header=["noheader","header"],this.isMutable.header=!0,this.isMutable.integrity=!1,this.utils.validateArgs(e,!0)}encode(e,...t){return super.encode(e,null,(({output:e,settings:t,zeroPadding:s})=>{const i=this.charsets[t.version],r=[...e],n=r.length;if(t.options.lineWrap=0,t.header&&!t.buffering){e=`begin ${t.options.permissions||T()} ${t.options.file||M()}\n`}else e="";for(let t=0;t<n;t+=60){const o=t+60,a=r.slice(t,o);if(o>=n){const t=this.converter.padChars(a.length)-s;e+=`${i.at(t)}${a.join("")}\n`}else e+=`${i.at(45)}${a.join("")}\n`}return t.buffering||(e+=`${i.at(0)}\n`,t.header&&(e+="end\n")),e}),...t)}decode(e,...t){let s=0;return super.decode(e,(({input:e,settings:t})=>{const i=this.charsets[t.version],r=e.trim().split(/\r?\n/),n=[];/^begin/i.test(r.at(0))&&r.shift();for(const e of r){const r=[...e],o=i.indexOf(r.shift());if(!(o>0))break;if(n.push(...r),45!==o){let e=r.length;if("original"===t.version){const t=k(o);for(;e<t;)e++,n.push(" ")}s=this.converter.padChars(e)-o;break}if(60!==r.length&&"original"===t.version)for(;n.length%60;)n.push(" ")}return n.join("")}),(({output:e})=>(s&&(e=new Uint8Array(e.slice(0,-s))),e)),!0,...t)}}const T=()=>{const e=()=>Math.floor(8*Math.random());return`${e()}${e()}${e()}`},M=()=>{const e=e=>e.at(Math.floor(Math.random()*e.length));return`${e(["unchronological","unconditionally","underemphasized","underprivileged","undistinguished","unsophisticated","untitled","untitled-1","untitled-3","uuencode"])}.${e(["applescript","bat","beam","bin","exe","js","mam","py","sh","vdo","wiz"])}`},k=e=>{const t=e/3*4;return t%4?4*Math.floor(t/4)+4:t};class C extends b{constructor(...e){super(),this.converter=new y(85,4,5,84),this.charsets.adobe=[..."!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstu"],this.charsets.ascii85=this.charsets.adobe.slice(),this.charsets.rfc1924=[..."0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~"],this.charsets.z85=[..."0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#"],this.version="ascii85",this.utils.validateArgs(e,!0)}encode(e,...t){return super.encode(e,(e=>{let t;return e.version.match(/adobe|ascii85/)&&(t=(e,t)=>t||"!!!!!"!==e?e:"z"),t}),(({output:e,settings:t,zeroPadding:s})=>{if(s){const t=this.converter.padBytes(s);e=e.slice(0,-t)}return"adobe"===t.version&&(e=`<~${e}~>`),e}),...t)}decode(e,...t){return super.decode(e,(({input:e,settings:t})=>(t.version.match(/adobe|ascii85/)&&(e=e.replace(/z/g,"!!!!!"),"adobe"===t.version&&(e=e.replace(/^<~|~>$/g,""))),e)),null,!1,...t)}}class B extends b{constructor(...e){super(),this.converter={radix:91,bsEnc:0,bsDec:0},this.charsets.default=[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~"'],this.version="default",this.utils.validateArgs(e,!0)}encode(e,...t){const s=this.utils.validateArgs(t),i=this.utils.inputHandler.toBytes(e,s)[0];let r=0,n=0,o="";const a=this.charsets[s.version];if(i.forEach((e=>{if(n+=e<<r,r+=8,r>13){let e,t,s=13,i=n%8192;i<89&&(s=14,i=n%16384),n>>=s,r-=s,[e,t]=this.#i(i,91),o=`${o}${a[t]}${a[e]}`}})),r){let e,t;[e,t]=this.#i(n,91),o=o.concat(a[t]),(r>7||n>90)&&(o=o.concat(a[e]))}return this.utils.wrapOutput(o,s.options.lineWrap)}decode(e,...t){const s=this.utils.validateArgs(t),i=this.charsets[s.version];e=this.utils.normalizeInput(e);let r=[...e];s.integrity||(r=r.filter((e=>i.includes(e))));let n=r.length,o=!1;n%2&&(o=!0,n--);let a=0,h=0;const l=new Array;for(let e=0;e<n;e+=2){const t=i.indexOf(r[e]),s=i.indexOf(r[e+1]);if(t<0)throw new p(r[e]);if(s<0)throw new p(r[e+1]);const n=t+91*s;a=(n<<h)+a,h+=n%8192>88?13:14;do{l.push(a%256),a>>=8,h-=8}while(h>7)}if(o){const e=r.at(n),t=i.indexOf(e);l.push(((t<<h)+a)%256)}const c=Uint8Array.from(l);return this.utils.outputHandler.compile(c,s.outputType)}#i(e,t){return[Math.floor(e/t),e%t]}}class j extends b{constructor(...e){super(),this.converter=new y(10,0,0),this.hexlify=new y(16,1,2),this.charsets.default="<placeholder>",this.charsets.hex="<placeholder>",this.version="default",this.frozenCharsets=!0,this.littleEndian=!0,this.hasSignedMode=!0,this.isMutable.signed=!0,this.utils.validateArgs(e,!0)}encode(e,...t){const s=this.utils.validateArgs(t),i=s.signed;s.signed=!0;const[r,n]=this.utils.inputHandler.toBytes(e,s);let o=this.converter.encode(r,null,s.littleEndian)[0],a=BigInt(o),h=new Array;if(n){if(!i)throw new TypeError("Negative values in unsigned mode are invalid.");a=-a}if(i)for(;;){const e=Number(127n&a);if(a>>=7n,0==a&&0==(64&e)||-1==a&&0!=(64&e)){h.push(e);break}h.push(128|e)}else for(;;){const e=Number(127n&a);if(a>>=7n,0==a){h.push(e);break}h.push(128|e)}const l=Uint8Array.from(h);return"hex"===s.version?this.hexlify.encode(l,[..."0123456789abcdef"],!1)[0]:l}decode(e,...t){const s=this.utils.validateArgs(t);if("hex"===s.version)e=this.hexlify.decode(this.utils.normalizeInput(e).toLowerCase(),[..."0123456789abcdef"],[],s.integrity,!1);else{if(void 0===e.byteLength)throw new TypeError("Input must be a bytes like object.");e=a.toBytes(e)[0]}if(1===e.length&&!e[0])return this.utils.outputHandler.compile(new Uint8Array(1),s.outputType,!0);e=Array.from(e);let i,r,n,o=0n,h=-7n;for(i of e)h+=7n,o+=BigInt(127&i)<<h;s.signed&&0!=(64&i)&&(o|=-(1n<<h+7n)),[r,n]=this.utils.extractSign(o.toString());const l=this.converter.decode(r,[..."0123456789"],[],s.integrity,!0);return this.utils.outputHandler.compile(l,s.outputType,!0,n)}}class I extends b{#r={};#n=null;constructor(...e){super(),this.charsets.emojis_v1=[..."🀄🃏🅰🅱🅾🅿🆎🆑🆒🆓🆔🆕🆖🆗🆘🆙🆚🇦🇧🇨🇩🇪🇫🇬🇭🇮🇯🇰🇱🇲🇳🇴🇵🇶🇷🇸🇹🇺🇻🇼🇽🇾🇿🈁🈂🈚🈯🈲🈳🈴🈵🈶🈷🈸🈹🈺🉐🉑🌀🌁🌂🌃🌄🌅🌆🌇🌈🌉🌊🌋🌌🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜🌝🌞🌟🌠🌡🌤🌥🌦🌧🌨🌩🌪🌫🌬🌭🌮🌯🌰🌱🌲🌳🌴🌵🌶🌷🌸🌹🌺🌻🌼🌽🌾🌿🍀🍁🍂🍃🍄🍅🍆🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🍔🍕🍖🍗🍘🍙🍚🍛🍜🍝🍞🍟🍠🍡🍢🍣🍤🍥🍦🍧🍨🍩🍪🍫🍬🍭🍮🍯🍰🍱🍲🍳🍴🍵🍶🍷🍸🍹🍺🍻🍼🍽🍾🍿🎀🎁🎂🎃🎄🎅🎆🎇🎈🎉🎊🎋🎌🎍🎎🎏🎐🎑🎒🎓🎖🎗🎙🎚🎛🎞🎟🎠🎡🎢🎣🎤🎥🎦🎧🎨🎩🎪🎫🎬🎭🎮🎯🎰🎱🎲🎳🎴🎵🎶🎷🎸🎹🎺🎻🎼🎽🎾🎿🏀🏁🏂🏃🏄🏅🏆🏇🏈🏉🏊🏋🏌🏎🏏🏐🏑🏒🏓🏔🏕🏖🏗🏘🏙🏚🏛🏜🏝🏞🏟🏠🏡🏢🏣🏤🏥🏦🏧🏨🏩🏪🏫🏬🏭🏮🏯🏰🏳🏴🏵🏷🏸🏹🏺🏻🏼🏽🏾🏿🐀🐁🐂🐃🐄🐅🐆🐇🐈🐉🐊🐋🐌🐍🐎🐏🐐🐑🐒🐓🐔🐕🐖🐗🐘🐙🐚🐛🐜🐝🐞🐟🐠🐡🐢🐣🐤🐥🐦🐧🐨🐩🐪🐫🐬🐭🐮🐯🐰🐱🐲🐳🐴🐵🐶🐷🐸🐹🐺🐻🐼🐽🐾🐿👀👁👂👃👄👅👆👇👈👉👊👋👌👍👎👏👐👑👒👓👔👕👖👗👘👙👚👛👜👝👞👟👠👡👢👣👤👥👦👧👨👩👪👫👬👭👮👯👰👱👲👳👴👵👶👷👸👹👺👻👼👽👾👿💀💁💂💃💄💅💆💇💈💉💊💋💌💍💎💏💐💑💒💓💔💕💖💗💘💙💚💛💜💝💞💟💠💡💢💣💤💥💦💧💨💩💪💫💬💭💮💯💰💱💲💳💴💵💶💷💸💹💺💻💼💽💾💿📀📁📂📃📄📅📆📇📈📉📊📋📌📍📎📏📐📒📓📔📕📖📗📘📙📚📛📜📝📞📟📠📡📢📣📤📥📦📧📨📩📪📫📬📭📮📯📰📱📲📳📴📵📶📷📸📹📺📻📼📽📿🔀🔁🔂🔃🔄🔅🔆🔇🔈🔉🔊🔋🔌🔍🔎🔏🔐🔑🔒🔓🔔🔕🔖🔗🔘🔙🔚🔛🔜🔝🔞🔟🔠🔡🔢🔣🔤🔥🔦🔧🔨🔩🔪🔫🔬🔭🔮🔯🔰🔱🔲🔳🔴🔵🔶🔷🔸🔹🔺🔻🔼🔽🕉🕊🕋🕌🕍🕎🕐🕑🕒🕓🕔🕕🕖🕗🕘🕙🕚🕛🕜🕝🕞🕟🕠🕡🕢🕣🕤🕥🕦🕧🕯🕰🕳🕴🕵🕶🕷🕸🕹🕺🖇🖊🖋🖌🖍🖐🖕🖖🖤🖥🖨🖱🖲🖼🗂🗃🗄🗑🗒🗓🗜🗝🗞🗡🗣🗨🗯🗳🗺🗻🗼🗽🗾🗿😀😁😂😃😄😅😆😇😈😉😊😋😌😍😎😏😐😑😒😓😔😕😖😗😘😙😚😛😜😝😞😟😠😡😢😣😤😥😦😧😨😩😪😫😬😭😮😯😰😱😲😳😴😵😶😷😸😹😺😻😼😽😾😿🙀🙁🙂🙃🙄🙅🙆🙇🙈🙉🙊🙌🙍🙎🙏🚀🚁🚂🚃🚄🚅🚆🚇🚈🚉🚊🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚙🚚🚛🚜🚝🚞🚟🚠🚡🚢🚣🚤🚥🚦🚧🚨🚩🚪🚫🚬🚭🚮🚯🚰🚱🚲🚳🚴🚵🚶🚷🚸🚹🚺🚻🚼🚽🚾🚿🛀🛁🛂🛃🛄🛅🛋🛌🛍🛎🛏🛐🛑🛒🛠🛡🛢🛣🛤🛥🛩🛫🛬🛰🛳🛴🛵🛶🛷🛸🛹🤐🤑🤒🤓🤔🤕🤖🤗🤘🤙🤚🤛🤜🤝🤞🤟🤠🤡🤢🤣🤤🤥🤦🤧🤨🤩🤪🤫🤬🤭🤮🤯🤰🤱🤲🤳🤴🤵🤶🤷🤸🤹🤺🤼🤽🤾🥀🥁🥂🥃🥄🥅🥇🥈🥉🥊🥋🥌🥍🥎🥏🥐🥑🥒🥓🥔🥕🥖🥗🥘🥙🥚🥛🥜🥝🥞🥟🥠🥡🥢🥣🥤🥥🥦🥧🥨🥩🥪🥫🥬🥭🥮🥯🥰🥳🥴🥵🥶🥺🥼🥽🥾🥿🦀🦁🦂🦃🦄🦅🦆🦇🦈🦉🦊🦋🦌🦍🦎🦏🦐🦑🦒🦓🦔🦕🦖🦗🦘🦙🦚🦛🦜🦝🦞🦟🦠🦡🦢🦰🦱🦲🦳🦴🦵🦶🦷🦸🦹🧀🧁🧂🧐🧑🧒🧓🧔🧕"],this.padChars.emojis_v1=["⚜","🏍","📑","🙋","☕"],this.charsets.emojis_v2=[..."🀄🃏⏰⏳☔♈♉♊♋♌♍♎♏♐♑♒♓♿⚓⚡⚽⚾⛄⛅⛎⛔⛪⛲⛳⛵⛺⛽✊✋✨⭐🛕🛖🛗🛝🛞🛟🛺🈁🛻🤌🤏🤿🥱🥲🥸🥹🥻🦣🦤🦥🦦🦧🌀🌁🌂🌃🌄🌅🌆🌇🌈🌉🌊🌋🌌🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜🌝🌞🌟🌠🦨🦩🦪🦫🦬🦭🦮🦯🦺🦻🌭🌮🌯🌰🌱🌲🌳🌴🌵🦼🌷🌸🌹🌺🌻🌼🌽🌾🌿🍀🍁🍂🍃🍄🍅🍆🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🍔🍕🍖🍗🍘🍙🍚🍛🍜🍝🍞🍟🍠🍡🍢🍣🍤🍥🍦🍧🍨🍩🍪🍫🍬🍭🍮🍯🍰🍱🍲🍳🍴🍵🍶🍷🍸🍹🍺🍻🍼🦽🍾🍿🎀🎁🎂🎃🎄🎅🎆🎇🎈🎉🎊🎋🎌🎍🎎🎏🎐🎑🎒🎓🦾🦿🧃🧄🧅🧆🧇🎠🎡🎢🎣🎤🎥🧈🎧🎨🎩🎪🎫🎬🎭🎮🎯🎰🎱🎲🎳🎴🎵🎶🎷🎸🎹🎺🎻🎼🎽🎾🎿🏀🏁🏂🏃🏄🏅🏆🏇🏈🏉🏊🧉🧊🧋🏏🏐🏑🏒🏓🧌🧍🧎🧏🧖🧗🧘🧙🧚🧛🧜🧝🏠🏡🏢🏣🏤🏥🏦🧞🏨🏩🏪🏫🏬🏭🏮🏯🏰🧟🏴🧠🧢🏸🏹🏺🧣🧤🧥🧦🧧🐀🐁🐂🐃🐄🐅🐆🐇🐈🐉🐊🐋🐌🐍🐎🐏🐐🐑🐒🐓🐔🐕🐖🐗🐘🐙🐚🐛🐜🐝🐞🐟🐠🐡🐢🐣🐤🐥🐦🐧🐨🐩🐪🐫🐬🐭🐮🐯🐰🐱🐲🐳🐴🐵🐶🐷🐸🐹🐺🐻🐼🐽🐾🧨👀🧩👂👃👄👅👆👇👈👉👊👋👌👍👎👏👐👑👒👓👔👕👖👗👘👙👚👛👜👝👞👟👠👡👢👣👤👥👦👧👨👩👪👫👬👭👮👯👰👱👲👳👴👵👶👷👸👹👺👻👼👽👾👿💀💁💂💃💄💅💆💇💈💉💊💋💌💍💎💏💐💑💒💓💔💕💖💗💘💙💚💛💜💝💞💟💠💡💢💣💤💥💦💧💨💩💪💫💬💭💮💯💰💱💲💳💴💵💶💷💸🧪💺💻💼💽💾💿📀🧫📂📃📄🧬📆📇📈📉📊📋📌📍📎📏📐📒📓📔📕📖📗📘📙📚📛📜📝📞📟📠📡📢📣📤📥📦📧📨📩📪📫📬📭📮📯📰📱📲📳🧭📵📶📷📸📹📺📻📼🧮📿🧯🧰🧱🧲🧳🔅🔆🔇🔈🔉🔊🔋🔌🔍🔎🔏🔐🔑🔒🔓🔔🔕🔖🔗🔘🧴🧵🧶🧷🧸🧹🧺🧻🧼🧽🧾🧿🔥🔦🔧🔨🔩🔪🔫🔬🔭🔮🔯🔰🔱🔲🔳🩰🩱🩲🩳🩴🩸🩹🩺🩻🩼🪀🪁🕋🕌🕍🕎🪂🪃🪄🪅🪆🪐🪑🪒🪓🪔🪕🪖🪗🪘🪙🪚🪛🪜🪝🪞🪟🪠🪡🪢🪣🪤🪥🪦🪧🪨🪩🪪🪫🕺🪬🪰🪱🪲🪳🪴🖕🖖🖤🪵🪶🪷🪸🪹🪺🫀🫁🫂🫃🫄🫅🫐🫑🫒🫓🫔🫕🫖🫗🗻🗼🗽🗾🗿😀😁😂😃😄😅😆😇😈😉😊😋😌😍😎😏😐😑😒😓😔😕😖😗😘😙😚😛😜😝😞😟😠😡😢😣😤😥😦😧😨😩😪😫😬😭😮😯😰😱😲😳😴😵😶😷😸😹😺😻😼😽😾😿🙀🙁🙂🙃🙄🙅🙆🙇🙈🙉🙊🙌🙍🙎🙏🚀🚁🚂🚃🚄🚅🚆🚇🚈🚉🚊🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚙🚚🚛🚜🚝🚞🚟🚠🚡🚢🚣🚤🚥🚦🚧🚨🚩🚪🚫🚬🚭🚮🚯🚰🚱🚲🚳🚴🚵🚶🚷🚸🚹🚺🚻🚼🚽🚾🚿🛀🛁🛂🛃🛄🛅🫘🛌🫙🫠🫡🛐🛑🛒🫢🫣🫤🫥🫦🫧🫰🛫🛬🫱🫲🛴🛵🛶🛷🛸🛹🤐🤑🤒🤓🤔🤕🤖🤗🤘🤙🤚🤛🤜🤝🤞🤟🤠🤡🤢🤣🤤🤥🤦🤧🤨🤩🤪🤫🤬🤭🤮🤯🤰🤱🤲🤳🤴🤵🤶🤷🤸🤹🤺🤼🤽🤾🥀🥁🥂🥃🥄🥅🥇🥈🥉🥊🥋🥌🥍🥎🥏🥐🥑🥒🥓🥔🥕🥖🥗🥘🥙🥚🥛🥜🥝🥞🥟🥠🥡🥢🥣🥤🥥🥦🥧🥨🥩🥪🥫🥬🥭🥮🥯🥰🥳🥴🥵🥶🥺🥼🥽🥾🥿🦀🦁🦂🦃🦄🦅🦆🦇🦈🦉🦊🦋🦌🦍🦎🦏🦐🦑🦒🦓🦔🦕🦖🦗🦘🦙🦚🦛🦜🦝🦞🦟🦠🦡🦢🫳🫴🫵🫶🦴🦵🦶🦷🦸🦹🧀🧁🧂🧐🧑🧒🧓🧔🧕"],this.padChars.emojis_v2=["🥷","🛼","📑","🙋","☕"],this.#o(),this.converter=new y(1024,5,4),this.padding=!0,this.padCharAmount=5,this.nonASCII=!0,this.version="emojis_v2",this.isMutable.padding=!0,this.isMutable.trim=!0,this.trim=null,this.utils.converterArgs.trim=["notrim","trim"],this.utils.validateArgs(e,!0),null===this.trim&&(this.trim="emojis_v2"===this.version)}#o(){const e={},t=(e,t)=>{t.forEach((t=>{t in this.#r?this.#r[t].version+=e:this.#r[t]={version:e}}))},s=(t,s,i)=>{s.forEach((s=>{s in e?this.#r[s].version=3:(this.#r[s]={version:t,padding:i},e[s]=i)}))};t(1,this.charsets.emojis_v1),t(2,this.charsets.emojis_v2),s(1,this.padChars.emojis_v1.slice(0,-1),"last"),s(2,this.padChars.emojis_v2.slice(0,-1),"last"),s(1,this.padChars.emojis_v1.slice(-1),"fill"),s(2,this.padChars.emojis_v2.slice(-1),"fill");const i=[];for(const t in e)"last"===e[t]?i.push(t):i.push(`${t}+`);this.#n=new RegExp(i.join("|"),"g")}encode(e,...t){return super.encode(e,null,(({output:e,settings:t,zeroPadding:s})=>{const i=this.charsets[t.version];let r=[...e];if(s>1){const e=this.converter.padBytes(s);if(t.padding){const s=t.trim?1:e,i=new Array(s).fill(this.padChars[t.version].at(-1));r.splice(r.length-e,e,...i)}else r.splice(r.length-e,e)}else if(1===s){const e=i.indexOf(r.pop())>>8;r.push(this.padChars[t.version].at(e))}return r.join("")}),...t)}decode(e,...t){const s=this.utils.validateArgs(t);e=this.utils.normalizeInput(e);let i=s.version,r=null;"emojis_v1"!==s.version&&"emojis_v2"!==s.version||(r=3);const n=e=>{null!==r&&(r=this.#a(e,r,s.integrity),i=3===r?s.version:`emojis_v${r}`);const t=this.charsets[i],n=[...e],o=n.at(-1);let a=!1;for(let s=0,r=this.padChars[i].length-1;s<r;s++)if(o===this.padChars[i].at(s)){n.splice(-1,1,t.at(s<<8)),e=n.join(""),a=!0;break}let h=this.converter.decode(e,this.charsets[i],[],!1);return a&&(h=new Uint8Array(h.buffer.slice(0,-1))),h},o=[...e.matchAll(this.#n)];let a;if(o.length<2)a=n(e);else{const t=[];let s=0;o.forEach((i=>{const r=i.index+i.at(0).length;t.push(...n(e.slice(s,r))),s=r})),s!==e.length&&t.push(...n(e.slice(s,e.length))),a=Uint8Array.from(t)}return this.utils.outputHandler.compile(a,s.outputType)}#a(e,t,s){const i=[...e];let r;if(i.forEach(((e,i)=>{if(!(e in this.#r))throw new p(e);{const n=this.#r[e].version;if(3!==n)if(3===t)t=n;else if(t!==n)throw new TypeError(`Emojis from different ecoji versions seen : ${e} from emojis_v${n}`);if(s){const t=this.#r[e].padding;if(t){const s=i%4;if(r=!0,"fill"===t){if(0===s)throw new TypeError(`Padding unexpectedly seen in first position ${e}`)}else if(3!==s)throw new TypeError(`Last padding seen in unexpected position ${e}`)}else if(r)throw new TypeError("Unexpectedly saw non-padding after padding")}}})),s&&i.length%4&&(1===t||"fill"!==this.#r[i.at(-1)].padding))throw new TypeError("Unexpected end of data, input data size not multiple of 4");return t}}class $ extends b{constructor(...e){super(),this.converter={radix:2048,bsEnc:11,bsEncPad:3,bsDec:8},this.charsets.default=[..."89ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzÆÐØÞßæðøþĐđĦħıĸŁłŊŋŒœŦŧƀƁƂƃƄƅƆƇƈƉƊƋƌƍƎƏƐƑƒƓƔƕƖƗƘƙƚƛƜƝƞƟƢƣƤƥƦƧƨƩƪƫƬƭƮƱƲƳƴƵƶƷƸƹƺƻƼƽƾƿǀǁǂǃǝǤǥǶǷȜȝȠȡȢȣȤȥȴȵȶȷȸȹȺȻȼȽȾȿɀɁɂɃɄɅɆɇɈɉɊɋɌɍɎɏɐɑɒɓɔɕɖɗɘəɚɛɜɝɞɟɠɡɢɣɤɥɦɧɨɩɪɫɬɭɮɯɰɱɲɳɴɵɶɷɸɹɺɻɼɽɾɿʀʁʂʃʄʅʆʇʈʉʊʋʌʍʎʏʐʑʒʓʔʕʖʗʘʙʚʛʜʝʞʟʠʡʢʣʤʥʦʧʨʩʪʫʬʭʮʯͰͱͲͳͶͷͻͼͽͿΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρςστυφχψωϏϗϘϙϚϛϜϝϞϟϠϡϢϣϤϥϦϧϨϩϪϫϬϭϮϯϳϷϸϺϻϼϽϾϿЂЄЅІЈЉЊЋЏАБВГДЕЖЗИКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзиклмнопрстуфхцчшщъыьэюяђєѕіјљњћџѠѡѢѣѤѥѦѧѨѩѪѫѬѭѮѯѰѱѲѳѴѵѸѹѺѻѼѽѾѿҀҁҊҋҌҍҎҏҐґҒғҔҕҖҗҘҙҚқҜҝҞҟҠҡҢңҤҥҦҧҨҩҪҫҬҭҮүҰұҲҳҴҵҶҷҸҹҺһҼҽҾҿӀӃӄӅӆӇӈӉӊӋӌӍӎӏӔӕӘәӠӡӨөӶӷӺӻӼӽӾӿԀԁԂԃԄԅԆԇԈԉԊԋԌԍԎԏԐԑԒԓԔԕԖԗԘԙԚԛԜԝԞԟԠԡԢԣԤԥԦԧԨԩԪԫԬԭԮԯԱԲԳԴԵԶԷԸԹԺԻԼԽԾԿՀՁՂՃՄՅՆՇՈՉՊՋՌՍՎՏՐՑՒՓՔՕՖաբգդեզէըթժիլխծկհձղճմյնշոչպջռսվտրցւփքօֆאבגדהוזחטיךכלםמןנסעףפץצקרשתװױײؠءابةتثجحخدذرزسشصضطظعغػؼؽؾؿفقكلمنهوىي٠١٢٣٤٥٦٧٨٩ٮٯٱٲٳٴٹٺٻټٽپٿڀځڂڃڄڅچڇڈډڊڋڌڍڎڏڐڑڒړڔڕږڗژڙښڛڜڝڞڟڠڡڢڣڤڥڦڧڨکڪګڬڭڮگڰڱڲڳڴڵڶڷڸڹںڻڼڽھڿہۃۄۅۆۇۈۉۊۋیۍێۏېۑےەۮۯ۰۱۲۳۴۵۶۷۸۹ۺۻۼۿܐܒܓܔܕܖܗܘܙܚܛܜܝܞܟܠܡܢܣܤܥܦܧܨܩܪܫܬܭܮܯݍݎݏݐݑݒݓݔݕݖݗݘݙݚݛݜݝݞݟݠݡݢݣݤݥݦݧݨݩݪݫݬݭݮݯݰݱݲݳݴݵݶݷݸݹݺݻݼݽݾݿހށނރބޅކއވމފދތލގޏސޑޒޓޔޕޖޗޘޙޚޛޜޝޞޟޠޡޢޣޤޥޱ߀߁߂߃߄߅߆߇߈߉ߊߋߌߍߎߏߐߑߒߓߔߕߖߗߘߙߚߛߜߝߞߟߠߡߢߣߤߥߦߧߨߩߪࠀࠁࠂࠃࠄࠅࠆࠇࠈࠉࠊࠋࠌࠍࠎࠏࠐࠑࠒࠓࠔࠕࡀࡁࡂࡃࡄࡅࡆࡇࡈࡉࡊࡋࡌࡍࡎࡏࡐࡑࡒࡓࡔࡕࡖࡗࡘࡠࡡࡢࡣࡤࡥࡦࡧࡨࡩࡪࢠࢡࢢࢣࢤࢥࢦࢧࢨࢩࢪࢫࢬࢭࢮࢯࢰࢱࢲࢳࢴࢶࢷࢸࢹࢺࢻࢼࢽऄअआइईउऊऋऌऍऎएऐऑऒओऔकखगघङचछजझञटठडढणतथदधनपफबभमयरलळवशषसहऽॐॠॡ०१२३४५६७८९ॲॳॴॵॶॷॸॹॺॻॼॽॾॿঀঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহঽৎৠৡ০১২৩৪৫৬৭৮৯ৰৱ৴৵৶৷৸৹ৼਅਆਇਈਉਊਏਐਓਔਕਖਗਘਙਚਛਜਝਞਟਠਡਢਣਤਥਦਧਨਪਫਬਭਮਯਰਲਵਸਹੜ੦੧੨੩੪੫੬੭੮੯ੲੳੴઅઆઇઈઉઊઋઌઍએઐઑઓઔકખગઘઙચછજઝઞટઠડઢણતથદધનપફબભમયરલળવશષસહઽૐૠૡ૦૧૨૩૪૫૬૭૮૯ૹଅଆଇଈଉଊଋଌଏଐଓଔକଖଗଘଙଚଛଜଝଞଟଠଡଢଣତଥଦଧନପଫବଭମଯରଲଳଵଶଷସହଽୟୠୡ୦୧୨୩୪୫୬୭୮୯ୱ୲୳୴୵୶୷ஃஅஆஇஈஉஊஎஏஐஒஓகஙசஜஞடணதநனபமயரறலளழவஶஷஸஹௐ௦௧௨௩௪௫௬௭௮௯௰௱௲అఆఇఈఉఊఋఌఎఏఐఒఓఔకఖగఘఙచఛజఝఞటఠడఢణతథదధనపఫబభమయరఱలళఴవశషసహఽౘౙౚౠౡ౦౧౨౩౪౫౬౭౮౯౸౹౺౻౼౽౾ಀಅಆಇಈಉಊಋಌಎಏಐಒಓಔಕಖಗಘಙಚಛಜಝಞಟಠಡಢಣತಥದಧನಪಫಬಭಮಯರಱಲಳವಶಷಸಹಽೞೠೡ೦೧೨೩೪೫೬೭೮೯ೱೲഅആഇഈഉഊഋഌഎഏഐഒഓഔകഖഗഘങചഛജഝഞടഠഡഢണതഥദധനഩപഫബഭമയരറലളഴവശഷസഹഺഽൎൔൕൖ൘൙൚൛൜൝൞ൟൠൡ൦൧൨൩൪൫൬൭൮൯൰൱൲൳൴൵൶൷൸ൺൻർൽൾൿඅආඇඈඉඊඋඌඍඎඏඐඑඒඓඔඕඖකඛගඝඞඟචඡජඣඤඥඦටඨඩඪණඬතථදධනඳපඵබභමඹයරලවශෂසහළෆ෦෧෨෩෪෫෬෭෮෯กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะาเแโใไๅ๐๑๒๓๔๕๖๗๘๙ກຂຄງຈຊຍດຕຖທນບປຜຝພຟມຢຣລວສຫອຮຯະາຽເແໂໃໄ໐໑໒໓໔໕໖໗໘໙ໞໟༀ༠༡༢༣༤༥༦༧༨༩༪༫༬༭༮༯༰༱༲༳ཀཁགངཅཆཇཉཊཋཌཎཏཐདནཔཕབམཙཚཛཝཞཟའཡརལཤཥསཧཨཪཫཬྈྉྊྋྌကခဂဃငစဆဇဈဉညဋဌဍဎဏတထဒဓနပဖဗဘမယရလဝသဟဠအဢဣဤဥဧဨဩဪဿ၀၁၂၃၄၅၆၇၈၉ၐၑၒၓၔၕ"],this.padChars.default=[..."01234567"],this.padCharAmount=8,this.hasSignedMode=!0,this.littleEndian=!1,this.nonASCII=!0,this.utils.validateArgs(e,!0)}encode(e,...t){const s=this.utils.validateArgs(t);let i=this.utils.inputHandler.toBytes(e,s).at(0);const r=this.charsets[s.version],n=this.padChars[s.version];let o="",a=0,h=0;if(i.forEach((e=>{for(let t=this.converter.bsDec-1;t>=0;t--)a=(a<<1)+(e>>t&1),h++,h===this.converter.bsEnc&&(o+=r.at(a),a=0,h=0)})),0!==h){let e,t;for(h<=this.converter.bsEncPad?(e=this.converter.bsEncPad,t=!0):(e=this.converter.bsEnc,t=!1);h!==e;)if(a=1+(a<<1),h++,h>this.converter.bsEnc)throw new Error("Cannot process input. This is a bug!");o+=t?n.at(a):r.at(a)}return this.utils.wrapOutput(o,s.options.lineWrap)}decode(e,...t){const s=this.utils.validateArgs(t);e=this.utils.normalizeInput(e);const i=[...e],r=this.charsets[s.version],n=this.padChars[s.version],o=new Array;let a=0,h=0;return i.forEach(((e,t)=>{let l,c=r.indexOf(e);if(c>-1)l=this.converter.bsEnc;else if(c=n.indexOf(e),c>-1){if(t+1!==i.length)throw new p(null,`Secondary character found before end of input, index: ${t}`);l=this.converter.bsEncPad}else if(s.integrity)throw new p(e);for(let e=l-1;e>=0;e--)a=(a<<1)+(c>>e&1),h++,h===this.converter.bsDec&&(o.push(a),a=0,h=0)})),this.utils.outputHandler.compile(Uint8Array.from(o),s.outputType)}}class S extends b{constructor(e,...t){if(super(),!e||!Number.isInteger(e)||e<2||e>62)throw new RangeError("Radix argument must be provided and has to be an integer between 2 and 62.");this.converter=new y(e,0,0),this.charsets.default=[..."0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"].slice(0,e),this.frozenCharsets=!0,this.hasSignedMode=!0,this.littleEndian=!(2===e||16===e),this.signed=!0,this.version="default",this.isMutable.littleEndian=!0,this.isMutable.upper=e<=36,this.utils.validateArgs(t,!0)}encode(e,...t){return super.encode(e,null,null,...t)}decode(e,...t){return super.decode(e,(({input:e})=>{if(2===this.converter.radix){const t=(8-e.length%8)%8;e=`${"0".repeat(t)}${e}`}else if(16===this.converter.radix){const t=e.length%2;e=`${"0".repeat(t)}${e}`}return e}),null,!1,...t)}}let _=1e6,U="[big.js] ",N=U+"Invalid ",D=N+"decimal places",O=N+"rounding mode",P={},H=/^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;function z(e,t,s,i){let r=e.c;if(void 0===s&&(s=e.constructor.RM),0!==s&&1!==s&&2!==s&&3!==s)throw Error(O);if(t<1)i=3===s&&(i||!!r[0])||0===t&&(1===s&&r[0]>=5||2===s&&(r[0]>5||5===r[0]&&(i||void 0!==r[1]))),r.length=1,i?(e.e=e.e-t+1,r[0]=1):r[0]=e.e=0;else if(t<r.length){if(i=1===s&&r[t]>=5||2===s&&(r[t]>5||5===r[t]&&(i||void 0!==r[t+1]||1&r[t-1]))||3===s&&(i||!!r[0]),r.length=t,i)for(;++r[--t]>9;)if(r[t]=0,0===t){++e.e,r.unshift(1);break}for(t=r.length;!r[--t];)r.pop()}return e}function V(e,t,s){let i=e.e,r=e.c.join(""),n=r.length;if(t)r=r.charAt(0)+(n>1?"."+r.slice(1):"")+(i<0?"e":"e+")+i;else if(i<0){for(;++i;)r="0"+r;r="0."+r}else if(i>0)if(++i>n)for(i-=n;i--;)r+="0";else i<n&&(r=r.slice(0,i)+"."+r.slice(i));else n>1&&(r=r.charAt(0)+"."+r.slice(1));return e.s<0&&s?"-"+r:r}P.abs=function(){let e=new this.constructor(this);return e.s=1,e},P.cmp=function(e){let t,s=this,i=s.c,r=(e=new s.constructor(e)).c,n=s.s,o=e.s,a=s.e,h=e.e;if(!i[0]||!r[0])return i[0]?n:r[0]?-o:0;if(n!=o)return n;if(t=n<0,a!=h)return a>h^t?1:-1;for(o=(a=i.length)<(h=r.length)?a:h,n=-1;++n<o;)if(i[n]!=r[n])return i[n]>r[n]^t?1:-1;return a==h?0:a>h^t?1:-1},P.eq=function(e){return 0===this.cmp(e)},P.gt=function(e){return this.cmp(e)>0},P.gte=function(e){return this.cmp(e)>-1},P.lt=function(e){return this.cmp(e)<0},P.lte=function(e){return this.cmp(e)<1},P.minus=P.sub=function(e){let t,s,i,r,n=this,o=n.constructor,a=n.s,h=(e=new o(e)).s;if(a!=h)return e.s=-h,n.plus(e);let l=n.c.slice(),c=n.e,u=e.c,d=e.e;if(!l[0]||!u[0])return u[0]?e.s=-h:l[0]?e=new o(n):e.s=1,e;if(a=c-d){for((r=a<0)?(a=-a,i=l):(d=c,i=u),i.reverse(),h=a;h--;)i.push(0);i.reverse()}else for(s=((r=l.length<u.length)?l:u).length,a=h=0;h<s;h++)if(l[h]!=u[h]){r=l[h]<u[h];break}if(r&&(i=l,l=u,u=i,e.s=-e.s),(h=(s=u.length)-(t=l.length))>0)for(;h--;)l[t++]=0;for(h=t;s>a;){if(l[--s]<u[s]){for(t=s;t&&!l[--t];)l[t]=9;--l[t],l[s]+=10}l[s]-=u[s]}for(;0===l[--h];)l.pop();for(;0===l[0];)l.shift(),--d;return l[0]||(e.s=1,l=[d=0]),e.c=l,e.e=d,e},P.plus=P.add=function(e){let t,s,i,r=this,n=r.constructor;if(e=new n(e),r.s!=e.s)return e.s=-e.s,r.minus(e);let o=r.e,a=r.c,h=e.e,l=e.c;if(!a[0]||!l[0])return l[0]||(a[0]?e=new n(r):e.s=r.s),e;if(a=a.slice(),t=o-h){for(t>0?(h=o,i=l):(t=-t,i=a),i.reverse();t--;)i.push(0);i.reverse()}for(a.length-l.length<0&&(i=l,l=a,a=i),t=l.length,s=0;t;a[t]%=10)s=(a[--t]=a[t]+l[t]+s)/10|0;for(s&&(a.unshift(s),++h),t=a.length;0===a[--t];)a.pop();return e.c=a,e.e=h,e},P.round=function(e,t){if(void 0===e)e=0;else if(e!==~~e||e<-_||e>_)throw Error(D);return z(new this.constructor(this),e+this.e+1,t)},P.toFixed=function(e,t){let s=this,i=s.c[0];if(void 0!==e){if(e!==~~e||e<0||e>_)throw Error(D);for(s=z(new s.constructor(s),e+s.e+1,t),e=e+s.e+1;s.c.length<e;)s.c.push(0)}return V(s,!1,!!i)},P[Symbol.for("nodejs.util.inspect.custom")]=P.toJSON=P.toString=function(){let e=this,t=e.constructor;return V(e,e.e<=t.NE||e.e>=t.PE,!!e.c[0])},P.toNumber=function(){let e=Number(V(this,!0,!0));if(!0===this.constructor.strict&&!this.eq(e.toString()))throw Error(U+"Imprecise conversion");return e};const L=function e(){function t(s){let i=this;if(!(i instanceof t))return void 0===s?e():new t(s);if(s instanceof t)i.s=s.s,i.e=s.e,i.c=s.c.slice();else{if("string"!=typeof s){if(!0===t.strict&&"bigint"!=typeof s)throw TypeError(N+"value");s=0===s&&1/s<0?"-0":String(s)}!function(e,t){let s,i,r;if(!H.test(t))throw Error(`${N}number`);for(e.s="-"==t.charAt(0)?(t=t.slice(1),-1):1,(s=t.indexOf("."))>-1&&(t=t.replace(".","")),(i=t.search(/e/i))>0?(s<0&&(s=i),s+=+t.slice(i+1),t=t.substring(0,i)):s<0&&(s=t.length),r=t.length,i=0;i<r&&"0"==t.charAt(i);)++i;if(i==r)e.c=[e.e=0];else{for(;r>0&&"0"==t.charAt(--r););for(e.e=s-i-1,e.c=[],s=0;i<=r;)e.c[s++]=+t.charAt(i++)}}(i,s)}i.constructor=t}return t.prototype=P,t.DP=20,t.RM=1,t.NE=-7,t.PE=21,t.strict=false,t.roundDown=0,t.roundHalfUp=1,t.roundHalfEven=2,t.roundUp=3,t}();class F extends b{#h=L("1.618033988749894848204586834365638117720309179805762862135448622705260462818902449707207204189391137484754088075386891752");constructor(...e){super(),this.converter={radix:2,bsEnc:0,bsDec:0},this.b10=new y(10,0,0),this.charsets.default=["0","1"],this.version="default",this.signed=!0,this.hasDecimalMode=!0,this.utils.validateArgs(e,!0)}encode(e,...t){const s=this.utils.validateArgs(t),i=this.charsets[s.version];let r,n,o,a="";if(s.decimalMode){if(!Number.isFinite(e))throw new TypeError("When running the converter in decimal-mode, only input of type 'Number' is allowed.");e<0?(n=!0,o=L(-e)):(n=!1,o=L(e))}else[r,n]=this.utils.inputHandler.toBytes(e,s),o=L(this.b10.encode(r,null,s.littleEndian)[0]);if(o.eq(0)||o.eq(1))return a=i[o.toNumber()],n&&(a=`-${a}`),a;const h=[],l=[];let c=L(1),u=this.#h,d=0;for(;u.lt(o);)[c,u]=this.#l(c,u),d++;const f=(e,t,s)=>{if(!this.#c(o)){for(;e.gt(o);){if([e,t]=this.#u(e,t),e.lte(0))return void console.warn("Could not find an exact base-phi representation. Value is approximated.");s--}s>-1?h.unshift(s):l.push(s),o=o.minus(e),f(e,t,s)}};return f(c,u,d),d=0,h.forEach((e=>{for(;d<e;)a=`${i[0]}${a}`,d++;a=`${i[1]}${a}`,d++})),a?a+=".":a="0.",d=-1,l.forEach((e=>{for(;d>e;)a+=i[0],d--;a+=i[1],d--})),n&&(a=`-${a}`),a}decode(e,...t){const s=this.utils.validateArgs(t),i=this.charsets[s.version];let r;if([e,r]=this.utils.extractSign(this.utils.normalizeInput(e)),!s.integrity){const t=[...i,"."];e=[...e].filter((e=>t.includes(e))).join("")}const n=e.split(".");if(s.integrity&&n.length>2)throw new p(null,"There are multiple decimal points in the input.");const[o,a]=n;let h=L(0),l=this.#h.minus(1),c=L(1);if([...o].reverse().forEach((e=>{const t=i.indexOf(e);if(1===t)h=h.plus(c);else if(0!==t)throw new p(e);[l,c]=this.#l(l,c)})),a){let e=L(1);c=this.#h.minus(e),[...a].forEach((t=>{const s=i.indexOf(t);if(1===s)h=h.plus(c);else if(0!==s)throw new p(t);[c,e]=this.#u(c,e)}))}if(s.decimalMode)return h.toNumber();h=h.round().toFixed();const u=this.b10.decode(h,[..."0123456789"],[],s.integrity,s.littleEndian);return this.utils.outputHandler.compile(u,s.outputType,s.littleEndian,r)}#c(e){return!e.round(50).abs().toNumber()}#l(e,t){return[t,e.plus(t)]}#u(e,t){return[t.minus(e),e]}}const K=(()=>{const e=new Uint16Array([1]),t=new Uint8Array(e.buffer);return Boolean(t.at(0))})();class R{constructor(...e){this.littleEndian=K,this.numberMode=!1,this.outputType="buffer",this.utils={validateArgs:(e,t=!1)=>{const s={littleEndian:this.littleEndian,numberMode:this.numberMode,outputType:this.outputType,signed:!1};if(!e.length)return s;e.includes("number")&&(e.splice(e.indexOf("number"),1),s.numberMode=!0,s.outputType="float_n");const i=c.typeList.map((e=>`'${e}'`)).join(", ");if(e.forEach((e=>{if("le"===(e=String(e).toLowerCase()))s.littleEndian=!0;else if("be"===e)s.littleEndian=!1;else{if(!c.typeList.includes(e))throw new TypeError(`Invalid argument: '${e}.\nValid arguments are:\n'le', 'be', ${i}`);s.outputType=e}})),t)for(const e in s)this[e]=s[e];return s}},this.utils.validateArgs(e,!0)}encode(e,...t){const s=this.utils.validateArgs(t);return l.toBytes(e,s)[0]}decode(e,...t){const s=this.utils.validateArgs(t);return c.compile(e,s.outputType,s.littleEndian)}}
/**
     * [BaseEx]{@link https://github.com/UmamiAppearance/BaseExJS}
     *
     * @version 0.8.1
     * @author UmamiAppearance [mail@umamiappearance.eu]
     * @license MIT
     */class q{constructor(e="buffer"){if(!d.typeList.includes(e)){let t=`Invalid argument '${e}' for output type. Allowed types are:\n`;throw t=t.concat(d.typeList.join(", ")),new TypeError(t)}this.base1=new w("default",e),this.base16=new m("default",e),this.base32_crockford=new v("rfc4648",e),this.base32_rfc3548=new v("rfc3548",e),this.base32_rfc4648=new v("rfc4648",e),this.base32_zbase32=new v("zbase32",e),this.base58=new E("default",e),this.base58_bitcoin=new E("bitcoin",e),this.base58_flickr=new E("flickr",e),this.base64=new A("default",e),this.base64_urlsafe=new A("urlsafe",e),this.uuencode=new x("default",e),this.uuencode_original=new x("original",e),this.xxencode=new x("xx",e),this.base85_adobe=new C("adobe",e),this.base85_ascii=new C("ascii85",e),this.base85_z85=new C("z85",e),this.base91=new B("default",e),this.leb128=new j("default",e),this.ecoji_v1=new I("emojis_v1",e),this.ecoji_v2=new I("emojis_v2",e),this.base2048=new $("default",e),this.basePhi=new F("default",e),this.byteConverter=new R(e),this.simpleBase={};for(let t=2;t<=62;t++)this.simpleBase[`base${t}`]=new S(t,e)}}
/**
     * [HMACObj]{@link https://github.com/UmamiAppearance/HMACObj}
     *
     * @version 1.0.5
     * @author UmamiAppearance [mail@umamiappearance.eu]
     * @license MIT
     */let W;if(void 0===q)throw new Error("BaseEx is required for this module to work. Please make sure the whole library or the BaseEx class can be globally found under the name 'BaseEx'.");W="BaseEx"in q?new q.BaseEx:new q;const G=["SHA-1","SHA-256","SHA-384","SHA-512"],Y=["raw","jwk"];return class{#d=null;#f=null;#p=null;#g=[];#y=null;#b=this.constructor.keyFormats();#w=null;constructor(e){[this.#p,this.#d]=o(e,G),this.#m()}static baseEx=W;static digestmodsAvailable(){return new Set(G)}static keyFormats(){return new Set(Y)}static async generateKey(e="",t=!1){return e=o(e,G).at(0),await s(e,t)}static compareDigest(e,t){if(void 0===e||void 0===t)throw new Error("HMACobj.compareDigest takes exactly two positional arguments.");let s,i;e=W.byteConverter.encode(e,"uint8"),t=W.byteConverter.encode(t,"uint8"),e.byteLength>t.byteLength?(s=e,i=t):(s=t,i=e);const r=s.map(((e,t)=>e===i.at(t)));return Boolean(r.reduce(((e,t)=>e*t)))}static async new(e=null,t=null,s="",i="raw",r=!1){const n=new this(s);return e&&("object"===i?await n.setKey(e):await n.importKey(e,i,r)),null!==t&&(e||(await n.generateKey(),console.warn("A message but no key was provided. The key was generated for you.")),await n.update(t)),n}get digestSize(){return this.#d/8}get blockSize(){return this.#d>256?128:64}get name(){return"HMAC-"+this.#p}#v(e){return W.byteConverter.encode(e,"bytes")}#E(e){if(!this.#b.has(e))throw new TypeError(`Invalid key format '${e}'\n\nValid formats are: ${Y.join(", ")}`)}#A(){if(null===this.#y)throw new Error("No key is assigned yet. Import or generate key.")}#x(e,t){const s="Invalid base conversion keyword.";var i;if(i=t.replace(/^to/,""),"hex"===(t=i.charAt(0).toLowerCase().concat(i.slice(1)))||"hexdigest"==t)t="base16";else if("bytes"===t)t="byteConverter";else if(/SimpleBase/i.test(t)){if(!((t="base"+(0|[].concat(String(t).match(/[0-9]+/)).at(0)))in W.simpleBase))throw new TypeError(s);return W.simpleBase[t].encode(e)}if(!(t in W))throw new TypeError(s);return W[t].encode(e)}async update(e,t=!1){e=this.#v(e),this.#A(),this.#g=t?Array.from(e):this.#g.concat(Array.from(e)),this.#f=await r(Uint8Array.from(this.#g),this.#y)}async replace(e){await this.update(e,!0)}async setKey(e){this.#y=e,this.#g.length&&(console.warn("A new crypto key was established. A fresh digest is now getting calculated."),this.#f=await r(Uint8Array.from(this.#g),this.#y))}async importKey(e,s="raw",i=!1){"raw"===s?e=this.#v(e):this.#E(s),this.#w=i;const r=await t(e,this.#p,s,i);await this.setKey(r)}async generateKey(e=!0){this.#w=Boolean(e);const t=await s(this.#p,this.#w);await this.setKey(t)}async exportKey(t="raw"){if(this.#E(t),null===this.#y)throw new Error("Key is unset.");if(!this.#w)throw new e("Key exports are not allowed. You have to permit this before key-generation.");return await i(this.#y,t)}async copy(){return await this.constructor.new(this.#y,this.#g.length?Uint8Array.from(this.#g):null,this.#p,"object",this.#w)}async sign(e,t=null){this.#A(),e=this.#v(e);const s=await r(e,this.#y);return null!==t?this.#x(s,t):s}async verify(e,t){if(e=this.#v(e),this.#A(),null===this.signature)throw new TypeError("Signature must be provided");return await n(e,t,this.#y)}digest(){return this.#f}#m(){const e=(e,t)=>e.splice(e.indexOf(t),1),t=e=>e.charAt(0).toUpperCase().concat(e.slice(1));this.hexdigest=()=>this.#f?W.base16.encode(this.#f):null;const s=Object.keys(W);this.basedigest={toSimpleBase:{}},e(s,"base1"),e(s,"byteConverter"),e(s,"simpleBase");for(const e of s)this.basedigest[`to${t(e)}`]=(...t)=>this.#f?W[e].encode(this.#f,...t):null;for(const e in W.simpleBase)this.basedigest.toSimpleBase[t(e)]=(...t)=>this.#f?W.simpleBase[e].encode(this.#f,...t):null;this.basedigest.toBytes=(...e)=>this.#f?W.byteConverter.encode(this.#f,...e):null}}}();
