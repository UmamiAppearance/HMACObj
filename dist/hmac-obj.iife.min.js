var HMACObj=function(){"use strict";class e extends Error{constructor(e){super(e),this.name="PermissionError"}}const t=async(e,t,s="raw",i=!1)=>await globalThis.crypto.subtle.importKey(s,e,{name:"HMAC",hash:{name:t}},i,["sign","verify"]),s=async(e,t=!1)=>await globalThis.crypto.subtle.generateKey({name:"HMAC",hash:{name:e}},t,["sign","verify"]),i=async(t,s="raw")=>{if(!t.extractable)throw new e("Key exports are not allowed. You can permit this during key-generation.");return await globalThis.crypto.subtle.exportKey(s,t)},r=async(e,t)=>await globalThis.crypto.subtle.sign({name:"HMAC",hash:t.algorithm.hash.name},t,e),a=async(e,t,s)=>await globalThis.crypto.subtle.verify("HMAC",s,t,e),n=(e,t)=>{if(!e)throw new TypeError("Missing required parameter 'digestmod'.");let s=0|[].concat(String(e).match(/[0-9]+/)).at(0);if(e=`SHA-${s}`,!t.includes(e))throw new TypeError(`Available digestmod are: '${t.join(", ")}'.`);return 1===s&&(s=160),[e,s]};
/**
     * [HMACObj]{@link https://github.com/UmamiAppearance/HMACObj}
     *
     * @version 1.0.5
     * @author UmamiAppearance [mail@umamiappearance.eu]
     * @license MIT
     */
let o;if("undefined"==typeof BaseEx)throw new Error("BaseEx is required for this module to work. Please make sure the whole library or the BaseEx class can be globally found under the name 'BaseEx'.");o="BaseEx"in BaseEx?new BaseEx.BaseEx:new BaseEx;const l=["SHA-1","SHA-256","SHA-384","SHA-512"],h=["raw","jwk"];return class{#e=null;#t=null;#s=null;#i=[];#r=null;#a=this.constructor.keyFormats();#n=null;constructor(e){[this.#s,this.#e]=n(e,l),this.#o()}static baseEx=o;static digestmodsAvailable(){return new Set(l)}static keyFormats(){return new Set(h)}static async generateKey(e="",t=!1){return e=n(e,l).at(0),await s(e,t)}static compareDigest(e,t){if(void 0===e||void 0===t)throw new Error("HMACobj.compareDigest takes exactly two positional arguments.");let s,i;e=o.byteConverter.encode(e,"uint8"),t=o.byteConverter.encode(t,"uint8"),e.byteLength>t.byteLength?(s=e,i=t):(s=t,i=e);const r=s.map(((e,t)=>e===i.at(t)));return Boolean(r.reduce(((e,t)=>e*t)))}static async new(e=null,t=null,s="",i="raw",r=!1){const a=new this(s);return e&&("object"===i?await a.setKey(e):await a.importKey(e,i,r)),null!==t&&(e||(await a.generateKey(),console.warn("A message but no key was provided. The key was generated for you.")),await a.update(t)),a}get digestSize(){return this.#e/8}get blockSize(){return this.#e>256?128:64}get name(){return"HMAC-"+this.#s}#l(e){return o.byteConverter.encode(e,"bytes")}#h(e){if(!this.#a.has(e))throw new TypeError(`Invalid key format '${e}'\n\nValid formats are: ${h.join(", ")}`)}#y(){if(null===this.#r)throw new Error("No key is assigned yet. Import or generate key.")}#c(e,t){const s="Invalid base conversion keyword.";var i;if(i=t.replace(/^to/,""),"hex"===(t=i.charAt(0).toLowerCase().concat(i.slice(1)))||"hexdigest"==t)t="base16";else if("bytes"===t)t="byteConverter";else if(/SimpleBase/i.test(t)){if(!((t="base"+(0|[].concat(String(t).match(/[0-9]+/)).at(0)))in o.simpleBase))throw new TypeError(s);return o.simpleBase[t].encode(e)}if(!(t in o))throw new TypeError(s);return o[t].encode(e)}async update(e,t=!1){e=this.#l(e),this.#y(),this.#i=t?Array.from(e):this.#i.concat(Array.from(e)),this.#t=await r(Uint8Array.from(this.#i),this.#r)}async replace(e){await this.update(e,!0)}async setKey(e){this.#r=e,this.#i.length&&(console.warn("A new crypto key was established. A fresh digest is now getting calculated."),this.#t=await r(Uint8Array.from(this.#i),this.#r))}async importKey(e,s="raw",i=!1){"raw"===s?e=this.#l(e):this.#h(s),this.#n=i;const r=await t(e,this.#s,s,i);await this.setKey(r)}async generateKey(e=!0){this.#n=Boolean(e);const t=await s(this.#s,this.#n);await this.setKey(t)}async exportKey(t="raw"){if(this.#h(t),null===this.#r)throw new Error("Key is unset.");if(!this.#n)throw new e("Key exports are not allowed. You have to permit this before key-generation.");return await i(this.#r,t)}async copy(){return await this.constructor.new(this.#r,this.#i.length?Uint8Array.from(this.#i):null,this.#s,"object",this.#n)}async sign(e,t=null){this.#y(),e=this.#l(e);const s=await r(e,this.#r);return null!==t?this.#c(s,t):s}async verify(e,t){if(e=this.#l(e),this.#y(),null===this.signature)throw new TypeError("Signature must be provided");return await a(e,t,this.#r)}digest(){return this.#t}#o(){const e=(e,t)=>e.splice(e.indexOf(t),1),t=e=>e.charAt(0).toUpperCase().concat(e.slice(1));this.hexdigest=()=>this.#t?o.base16.encode(this.#t):null;const s=Object.keys(o);this.basedigest={toSimpleBase:{}},e(s,"base1"),e(s,"byteConverter"),e(s,"simpleBase");for(const e of s)this.basedigest[`to${t(e)}`]=(...t)=>this.#t?o[e].encode(this.#t,...t):null;for(const e in o.simpleBase)this.basedigest.toSimpleBase[t(e)]=(...t)=>this.#t?o.simpleBase[e].encode(this.#t,...t):null;this.basedigest.toBytes=(...e)=>this.#t?o.byteConverter.encode(this.#t,...e):null}}}();
